# PAC  Peripheral Access Crate

? 当我们进行寄存器开发时，本质就向core peripheral 和device peripheral 这两个结构体进行配置，操作时为了多个引用同时存在并且不转移所有权，选择了不可变引用，操作时，在内部使用unsafe代码来修改

### **寄存器开发的本质**
在基于 Rust 的嵌入式开发中（如 STM32），我们操作的实际上是两个层次的外设结构体：
1. **Core Peripherals**（核心外设）：由 `cortex-m` 提供，包含 Cortex-M 内核的通用外设，例如 NVIC（Nested Vectored Interrupt Controller, 嵌套向量中断控制器）、SysTick、SCB（系统控制块）等。这些外设是 ARM Cortex-M 架构的标准组件，与具体 MCU 无关。
2. **Device Peripherals**（设备外设）：由 `stm32f1` 这类 PAC（Peripheral Access Crate）提供，包含特定 MCU（如 STM32F103C8T6）的硬件外设，例如 RCC、GPIO、TIM、USART 等。这些外设是芯片厂商（如 STMicroelectronics）定义的。

本质上，开发过程就是通过 Rust 的类型系统和内存映射，对这两个结构体的字段（寄存器）进行配置和操作。

---

### **为何选择不可变引用**
在你的描述中提到，为了允许多个引用同时存在且不转移所有权，选择了不可变引用（`&T`）。这是嵌入式开发中一个关键设计决策，原因如下：

#### **1. 外设的全局性和共享性**
- **全局单例**：核心外设和设备外设通常是全局资源，通过 `cortex_m::Peripherals::take()` 和 `stm32f1::Peripherals::take()` 获取。这两个方法返回的结构体是单例（Singleton），整个程序中只有一份。
- **多处访问需求**：在程序的不同部分，可能需要同时访问不同的外设（例如配置 GPIO 和定时器）。如果使用可变引用（`&mut T`），Rust 的借用规则会限制同一时刻只有一个地方能持有引用，这在嵌入式系统中会极大地限制灵活性。
- **不可变引用的分发**：通过不可变引用（`&T`），可以将外设的访问权限安全地分发到多个模块或函数，而无需担心所有权转移或借用冲突。

#### **2. 不转移所有权**
- **所有权问题**：如果外设结构体的所有权被转移（例如通过移动或返回），单例模式会被破坏，后续代码无法再访问该外设。
- **引用解耦**：使用不可变引用（`&T`）可以避免所有权问题，确保外设始终“属于”全局上下文，而程序的其他部分只是借用它。

#### **3. 硬件的特殊性**
- **硬件状态独立于 Rust 内存**：外设寄存器的值存储在硬件中（内存映射地址），而不是 Rust 的堆或栈中。Rust 的所有权和借用系统管理的是内存中的变量，而硬件寄存器的修改不影响这些变量的内存表示。因此，使用不可变引用并不违反硬件操作的实际需求。

---

### **内部使用 unsafe 修改**
由于 Rust 的内存安全规则不直接适用于硬件寄存器，寄存器操作依赖 `unsafe` 代码来绕过这些限制。以下是具体机制：

#### **1. 内存映射与 Volatile**
- 外设寄存器通过内存映射绑定到固定的硬件地址（例如 RCC 的基地址 `0x4002_1000`）。
- 这些地址被封装在 `Volatile<T>` 类型中，确保读写操作直接作用于硬件，且编译器不会优化掉“看似无用”的操作。
- 获取这些地址需要 `unsafe`，因为 Rust 无法静态验证硬件地址的有效性。例如：
  ```rust
  let rcc = unsafe { &*stm32f103::RCC::ptr() };
  ```

#### **2. modify 方法的实现**
- `modify` 方法通过 `unsafe` 直接操作 `Volatile` 字段。例如：
  ```rust
  pub fn modify<F>(&self, f: F)
  where
      F: FnOnce(&R, &mut W) -> &mut W,
  {
      let current = unsafe { self.value.read() }; // volatile 读
      let mut new_value = current;
      f(&current, &mut new_value); // 用户闭包修改
      unsafe { self.value.write(new_value) }; // volatile 写
  }
  ```
- 这里，`self` 是不可变引用，但 `unsafe` 块允许直接修改硬件寄存器的值。

#### **3. 安全性与封装**
- **外部安全**：通过 `modify` 这种接口，PAC 库将 `unsafe` 操作封装在内部，用户只需提供安全的闭包即可，避免直接接触底层的内存操作。
- **类型安全**：闭包中的读写视图（`&R` 和 `&mut W`）通过位字段（bit-field）API 提供类型化的操作，防止非法修改。

---

### **设计模式的优点**
综合来看，这种“不可变引用 + 内部 unsafe”的模式有以下优点：
1. **灵活性**：允许多个不可变引用共存，支持并发访问不同外设。
2. **安全性**：通过类型系统和封装，防止用户直接操作裸指针或错误配置寄存器。
3. **零成本抽象**：Rust 的编译器会优化掉这些抽象，最终生成的机器码与 C 语言直接操作寄存器几乎一致。

---

### **你的总结的验证**
你提到：
> “操作时为了多个引用同时存在并且不转移所有权，选择了不可变引用，操作时使用内部使用 unsafe 代码来修改。”

完全正确！这正是 Rust 嵌入式生态（如 `cortex-m` 和 `stm32f1`）的设计哲学：
- **不可变引用**解决了所有权和多引用问题。
- **内部 unsafe** 适配了硬件的特殊性，同时保持外部接口的安全性。

---

### **补充说明**
如果程序需要更严格的控制（例如确保某个外设在特定时刻只能被独占访问），可以选择使用 `&mut T` 或其他同步机制（如 `critical_section`）。但在大多数情况下，当前的设计已经足够满足嵌入式开发的需求。
