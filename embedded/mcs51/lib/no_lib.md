如果你不使用Keil提供的`reg52.h`头文件，而是自己声明和定义AT89C52的寄存器，可以通过直接指定字节地址和位地址来实现字节寻址和位寻址。这种方法需要你熟悉8051的存储器映射和SFR（特殊功能寄存器）的地址分配。以下是详细步骤和示例，分别说明如何声明和使用字节寻址与位寻址寄存器。

---

### **1. 字节寻址寄存器的声明与使用**

#### **声明方式**
- 在C语言中，使用`sfr`关键字定义特殊功能寄存器的字节地址。
- 你需要参考AT89C52的数据手册，找到每个寄存器的确切字节地址。例如：
  - P0（端口0）：`0x80`
  - P1（端口1）：`0x90`
  - ACC（累加器）：`0xE0`
  - TCON（定时器控制寄存器）：`0x88`

- 自定义声明示例：
  ```c
  sfr P0 = 0x80;    // 端口0的字节地址
  sfr P1 = 0x90;    // 端口1的字节地址
  sfr ACC = 0xE0;   // 累加器的字节地址
  sfr TCON = 0x88;  // 定时器控制寄存器的字节地址
  ```

#### **使用方式**
- 直接通过定义的符号名操作整个字节，像操作普通变量一样。
- 示例代码：
  ```c
  #include <reg52.h> // 不使用这个头文件，自己定义如下
  sfr P0 = 0x80;    // 声明P0
  sfr P1 = 0x90;    // 声明P1

  void main() {
      P0 = 0xFF;    // 将P0所有位设为1（全高电平）
      P1 = 0x00;    // 将P1所有位设为0（全低电平）
      ACC = P0;     // 将P0的值传送到累加器
      while (1);    // 死循环
  }
  ```

#### **注意事项**
- 地址必须与硬件手册一致。例如，P0的地址是`0x80`，不能随意更改。
- 字节寻址操作会影响整个8位数据。

---

### **2. 位寻址寄存器的声明与使用**

#### **声明方式**
- 在C语言中，使用`sbit`关键字定义某个字节寄存器中的某一位。
- 位地址可以通过两种方式指定：
  1. **直接使用位地址**：如`0x90`表示P1.0。
  2. **基于字节地址的位偏移**：用`^`符号指定某字节的第几位（从0到7）。

- **方法1：直接指定位地址**
  - 你需要知道每个位的具体位地址（参考数据手册）。例如：
    - P1.0：`0x90`
    - P1.1：`0x91`
    - TCON的IT0：`0x88`
  - 声明示例：
    ```c
    sbit P1_0 = 0x90;  // P1的第0位
    sbit P1_1 = 0x91;  // P1的第1位
    sbit IT0 = 0x88;   // TCON的IT0位
    ```

- **方法2：基于字节地址偏移**
  - 先声明字节地址，再用`^n`（n为0到7）指定位偏移。
  - 声明示例：
    ```c
    sfr P1 = 0x90;     // 先声明P1的字节地址
    sbit P1_0 = P1^0;  // P1的第0位
    sbit P1_1 = P1^1;  // P1的第1位
    sfr TCON = 0x88;   // 声明TCON的字节地址
    sbit IT0 = TCON^0; // TCON的第0位（IT0）
    ```

#### **使用方式**
- 通过定义的位变量直接操作单一位，支持赋值、取值和条件判断。
- 示例代码（基于位偏移方式）：
  ```c
  sfr P1 = 0x90;     // P1字节地址
  sbit P1_0 = P1^0;  // P1.0
  sbit P1_1 = P1^1;  // P1.1

  void main() {
      P1_0 = 1;      // 将P1.0置1（点亮P1.0的LED）
      P1_1 = 0;      // 将P1.1清0
      if (P1_0) {    // 检查P1.0是否为1
          P1_1 = 1;  // 如果P1.0为1，则将P1.1置1
      }
      while (1);
  }
  ```

- 示例代码（直接用位地址）：
  ```c
  sbit P1_0 = 0x90;  // P1.0的位地址
  sbit P1_1 = 0x91;  // P1.1的位地址

  void main() {
      P1_0 = 1;      // 将P1.0置1
      P1_1 = 0;      // 将P1.1清0
      while (1);
  }
  ```

#### **注意事项**
- **位地址范围**：只有特定区域支持位寻址：
  - 内部RAM：`20H-2FH`（位地址`00H-7FH`）。
  - SFR：部分寄存器（如`80H`、`88H`、`90H`等）支持位寻址。
- **偏移方式更常用**：基于字节地址的`^n`方式更直观，且便于维护。
- **仅限可位寻址寄存器**：不是所有SFR都支持位寻址，例如SP（`0x81`）就不可位寻址。

---

### **3. 综合示例**
以下是一个完整的自定义声明和使用的例子，控制P1口的LED并检测状态：
```c
// 自定义寄存器声明
sfr P1 = 0x90;      // P1的字节地址
sbit P1_0 = P1^0;   // P1.0
sbit P1_1 = P1^1;   // P1.1
sfr TCON = 0x88;    // TCON的字节地址
sbit TF0 = TCON^5;  // 定时器0溢出标志（位地址8DH）

void main() {
    P1 = 0x00;      // 初始化P1所有位为0
    P1_0 = 1;       // P1.0置1（点亮LED）
    if (TF0) {      // 检查定时器0是否溢出
        P1_1 = 1;   // 如果溢出，P1.1置1
    }
    while (1);
}
```

---

### **4. 如何获取地址信息**
如果你没有`reg52.h`，需要参考以下资源：
- **AT89C52数据手册**：查找SFR的字节地址和可位寻址的位地址。
- **常见SFR地址**（部分示例）：
  - P0：`0x80`，位地址`80H-87H`
  - P1：`0x90`，位地址`90H-97H`
  - TCON：`0x88`，位地址`88H-8FH`
  - SCON：`0x98`，位地址`98H-9FH`

---

### **5. 汇编语言中的定义与使用（可选补充）**
如果你使用汇编语言，自定义声明和使用方式如下：
- **字节寻址**：
  ```assembly
  P1 EQU 90H        ; 定义P1的字节地址
  MOV P1, #0FFH     ; P1所有位置1
  ```
- **位寻址**：
  ```assembly
  P1_0 BIT 90H      ; 定义P1.0的位地址
  SETB P1_0         ; P1.0置1
  ```

---

### **总结**
- **字节寻址**：用`sfr`定义字节地址，直接操作整个8位。
- **位寻址**：用`sbit`定义位地址（直接地址或基于字节偏移），操作单一位。
- **关键点**：确保地址正确（参考数据手册），区分字节和位的操作范围和用途。
